import app.StartDesktopApp;

// from evaluation dialog
import java.io.File;
import java.util.ArrayList;
import java.util.List;

import analysis.Complexity;
import app.DesktopApp;
import app.PlayerApp;
import app.loading.FileLoading;
import app.utils.AIPlayer;
import app.utils.ReportMessengerGUI;
import gnu.trove.map.hash.TObjectDoubleHashMap;
import main.grammar.Report;
import metrics.Evaluation;
import metrics.Metric;
import metrics.designer.IdealDuration;
import metrics.designer.SkillTrace;

// from gameEval
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.rng.RandomProviderState;
import org.apache.commons.rng.core.RandomProviderDefaultState;
import org.json.JSONObject;

import compiler.Compiler;
import game.Game;
import main.CommandLineArgParse;
import main.CommandLineArgParse.ArgOption;
import main.CommandLineArgParse.OptionTypes;
import main.Constants;
import main.FileHandling;
import main.grammar.Report;
import main.options.Ruleset;
import main.options.UserSelections;
import manager.network.DatabaseFunctionsPublic;
import manager.utils.game_logs.MatchRecord;
import metrics.Evaluation;
import metrics.Metric;
import other.AI;
import other.GameLoader;
import other.RankUtils;
import other.context.Context;
import other.move.Move;
import other.trial.Trial;
import utils.AIFactory;
import utils.DBGameInfo;

/**
 * The main method of this launches the Ludii application with its GUI, and registers
 * the example AIs from this project such that they are available inside the GUI.
 */
public class LaunchLudii
{
	
	//-------------------------------------------------------------------------
	
	/**
	 * Evaluates a given game.
	 */
	public static String evaluateGame
	(
		final Evaluation evaluation,
		final Report report,
		final Game originalGame,
		final List<String> gameOptions,
		final String AIName,
		final int numGames,
		final double thinkingTimeEach,
		final int maxNumTurns, 
		final List<Metric> metricsToEvaluate, 
		final ArrayList<Double> weights,
		final boolean useDatabaseGames
	)
	{
		final Game game = (Game)Compiler.compile(originalGame.description(), new UserSelections(gameOptions), report, false);		
		game.setMaxTurns(maxNumTurns);
		
		final List<AI> aiPlayers = new ArrayList<>();
		for (int i = 0; i < Constants.MAX_PLAYERS+1; i++)
		{
			final JSONObject json = new JSONObject().put("AI",new JSONObject().put("algorithm", AIName));
			aiPlayers.add(AIFactory.fromJson(json));
		}
		
		final double[] thinkingTime = new double[aiPlayers.size()];
		for (int p = 1; p < aiPlayers.size(); ++p)
			thinkingTime[p] = thinkingTimeEach;
		
		final DatabaseFunctionsPublic databaseFunctionsPublic = DatabaseFunctionsPublic.construct();
		String analysisPanelString = "";
		
		// Initialise the AI agents needed.
		final int numPlayers = game.players().count();
		for (int i = 0; i < numPlayers; ++i)
		{
			final AI ai = aiPlayers.get(i + 1);
			final int playerIdx = i + 1;
			
			if (ai == null)
			{
				final String message = "Cannot run evaluation; Player " + playerIdx + " is not AI.\n";
				try
				{
					report.getReportMessageFunctions().printMessageInAnalysisPanel(message);
				}
				catch(final Exception e)
				{
					// probably running from command line.
					System.out.println(message);
				}
				return "\n";
			}
			else if (!ai.supportsGame(game))
			{
				final String message = "Cannot run evaluation; " + ai.friendlyName() + " does not support this game.\n";
				try
				{
					report.getReportMessageFunctions().printMessageInAnalysisPanel(message);
				}
				catch(final Exception e)
				{
					// probably running from command line.
					System.out.println(message);
				}
				return "\n";
			}
		}
		
		System.err.println("Before message");
		
		final String message = "Please don't touch anything until complete! \nGenerating trials: \n";
		try
		{
			report.getReportMessageFunctions().printMessageInAnalysisPanel(message);
			System.err.println("Message printed");
		}
		catch(final Exception e)
		{
			// probably running from command line.
			System.out.println(message);
		}

		// If using Ludii AI, need to get the algorithm used.
		for (int p = 1; p <= game.players().count(); ++p)
			aiPlayers.get(p).initAI(game, p);
		String aiAlgorihtm = aiPlayers.get(1).name();
		if (aiAlgorihtm.length() > 7 && aiAlgorihtm.substring(0, 5).equals("Ludii"))
			aiAlgorihtm = aiAlgorihtm.substring(7, aiAlgorihtm.length()-1);
		
		// Get any valid trials that were in database.
		ArrayList<String> databaseTrials = new ArrayList<>();
		if (useDatabaseGames)
		{
			databaseTrials = databaseFunctionsPublic.getTrialsFromDatabase
			(
				game.name(), game.description().gameOptions().allOptionStrings(game.getOptions()), 
				aiAlgorihtm, thinkingTime[1], game.getMaxTurnLimit(), 
				game.description().raw().hashCode()
			);
			
			// Load files from a specific directory instead.
//			final String dirName = "/home/matthew/Downloads/Banqi"; "C:\Users\tiago\KCODE\Tese\ludii_games"
//			final File dir = new File(dirName);
//			final File[] allFiles = dir.listFiles();
//			for(final File file : allFiles)
//			{
//				String totalContents = "";
//				BufferedReader br;
//				try
//				{
//					br = new BufferedReader(new FileReader(file));
//					String line = null;
//				    while ((line = br.readLine()) != null) 
//				    {
//				    	totalContents += line + "\n";
//				    }
//				}
//				catch (final IOException e)
//				{
//					e.printStackTrace();
//				} 
//				databaseTrials.add(totalContents);
//			}
		}

		// Generate trials and print generic results.
		final List<Trial> allStoredTrials = new ArrayList<>();
		final List<RandomProviderState> allStoredRNG = new ArrayList<>();
		final double[] sumScores = new double[game.players().count() + 1];
		int numDraws = 0;
		int numTimeouts = 0;
		long sumNumMoves = 0L;
		final Context context = new Context(game, new Trial(game));
		
		System.err.println("Before try");
		try
		{
			for (int gameCounter = 0; gameCounter < numGames; ++gameCounter)
			{
				RandomProviderDefaultState rngState = (RandomProviderDefaultState) context.rng().saveState();
				boolean usingSavedTrial = false;
				List<Move> savedTrialMoves = new ArrayList<>();
				
				if (databaseTrials.size() > gameCounter)
				{
					usingSavedTrial = true;
					
					final Path tempFile = Files.createTempFile(null, null);
					Files.write(tempFile, databaseTrials.get(gameCounter).getBytes(StandardCharsets.UTF_8));
					final File file = new File(tempFile.toString());
					final MatchRecord savedMatchRecord = MatchRecord.loadMatchRecordFromTextFile(file, game);
					
					savedTrialMoves = savedMatchRecord.trial().generateCompleteMovesList();
					rngState = savedMatchRecord.rngState();
					context.rng().restoreState(rngState);
				}
				
				allStoredRNG.add(rngState);
				
				// Play a game
				game.start(context);
				for (int p = 1; p <= game.players().count(); ++p)
					aiPlayers.get(p).initAI(game, p);
				
				if (usingSavedTrial)
					for (int i = context.trial().numMoves(); i < savedTrialMoves.size(); i++)
						context.game().apply(context, savedTrialMoves.get(i));	

				while (!context.trial().over())
				{
					context.model().startNewStep
					(
						context, 
						aiPlayers, 
						thinkingTime, 
						-1, -1, 0.0,
						true, // block call until it returns
						false, false, 
						null, null
					);
					
					while (!context.model().isReady())
						Thread.sleep(100L);
				}
				
				final double[] utils = RankUtils.agentUtilities(context);
				for (int p = 1; p <= game.players().count(); ++p)
					sumScores[p] += (utils[p] + 1.0) / 2.0;	// convert [-1, 1] to [0, 1]
								
				if (context.trial().status().winner() == 0)
					++numDraws;
				
				if 
				(
					(
						context.state().numTurn() 
						>= 
						game.getMaxTurnLimit() * game.players().count()					
					)
					|| 
					(
						context.trial().numMoves() - context.trial().numInitialPlacementMoves() 
						>= 
						game.getMaxMoveLimit()
					)
				)
				{
					++numTimeouts;
				}
				
				sumNumMoves += context.trial().numMoves() - context.trial().numInitialPlacementMoves();
				
				try
				{
					report.getReportMessageFunctions().printMessageInAnalysisPanel(".");
				}
				catch(final Exception e)
				{
					// probably running from command line.
					System.out.print(".");
				}
				
				allStoredTrials.add(new Trial(context.trial()));
				
				if (!usingSavedTrial)					
					databaseFunctionsPublic.storeTrialInDatabase
					(
						game.name(), 
						game.description().gameOptions().allOptionStrings(game.getOptions()), 
						aiAlgorihtm, thinkingTime[1], game.getMaxTurnLimit(), 
						game.description().raw().hashCode(), new Trial(context.trial()), rngState
					);
				
				// Close AIs
				for (int p = 1; p < aiPlayers.size(); ++p)
					aiPlayers.get(p).closeAI();
			}
		}
		catch (final Exception e)
		{
			e.printStackTrace();
		}
		
		try
		{
			report.getReportMessageFunctions().printMessageInAnalysisPanel("\nCalculating metrics: \n");
		}
		catch(final Exception e)
		{
			// probably running from command line.
			System.out.print("\nTrials completed.\n");
		}
		
		System.err.println("after try");
		
		final DecimalFormat df = new DecimalFormat("#.#####");
		final String drawPercentage = df.format(numDraws*100.0/numGames) + "%";
		final String timeoutPercentage = df.format(numTimeouts*100.0/numGames) + "%";
		
		analysisPanelString += "\n\nAgent type: " + aiPlayers.get(0).friendlyName();
		analysisPanelString += "\nDraw likelihood: " + drawPercentage;
		analysisPanelString += "\nTimeout likelihood: " + timeoutPercentage;
		analysisPanelString += "\nAverage number of moves per game: " + df.format(sumNumMoves/(double)numGames);
		
		for (int i = 1; i < sumScores.length; i++)
			analysisPanelString += "\nPlayer " + (i) + " win rate: " + df.format(sumScores[i]*100.0/numGames) + "%";
		
		analysisPanelString += "\n\n";
		
		double finalScore = 0.0;
		
		String csvOutputString = DBGameInfo.getUniqueName(game) + ",";
		
		final Trial[] trials = allStoredTrials.toArray(new Trial[allStoredTrials.size()]);
		final RandomProviderState[] randomProviderStates = allStoredRNG.toArray(new RandomProviderState[allStoredRNG.size()]);
		
		System.err.println("Before metrics");
		// Specific Metric results
		for (int m = 0; m < metricsToEvaluate.size(); m++)
		{
			System.err.println("running metric");
			if (weights.get(m).doubleValue() == 0)
				continue;
			
			final Metric metric = metricsToEvaluate.get(m);
			
			try
			{
				report.getReportMessageFunctions().printMessageInAnalysisPanel(metric.name() + "\n");
			}
			catch(final Exception e)
			{
				// probably running from command line.
				System.out.print(metric.name() + "\n");
			}
			
			final Double score = metric.apply(game, evaluation, trials, randomProviderStates);			
			if (score == null)
			{
				csvOutputString += "NULL,";
			}
			else
			{
				final double weight = weights.get(m).doubleValue();
				analysisPanelString += metric.name() + ": " + df.format(score) + " (weight: " + weight + ")\n";
				finalScore += score.doubleValue() * weight;
				csvOutputString += score + ",";
			}
		}
		
		analysisPanelString += "Final Score: " + df.format(finalScore) + "\n\n";
				
		try
		{
			report.getReportMessageFunctions().printMessageInAnalysisPanel(analysisPanelString);	
		}
		catch (final Exception e)
		{
			// Probably running from command line
			System.out.println(analysisPanelString);
		}

		return csvOutputString.substring(0, csvOutputString.length()-1) + "\n";
	}
	
	//-------------------------------------------------------------------------
	
	
	/**
	 * Evaluates a single specified game and option combination, based on the AI parameters passed in.
	 */
	public static String evaluate(final PlayerApp app, final Report report, final int numberTrials, final int maxTurns, final double thinkTime, final String AIName, final List<Metric> metricsToEvaluate, final ArrayList<Double> weights, final boolean useDatabaseGames)
	{
		final Evaluation evaluation = new Evaluation();
		final Game game = app.manager().ref().context().game();
		final List<String> options = app.manager().settingsManager().userSelections().selectedOptionStrings();
		
		if (options.size() > 0)
			app.addTextToAnalysisPanel("Analysing " + game.name() + " " + options + "\n\n");
		else
			app.addTextToAnalysisPanel("Analysing " + game.name() + "\n\n");

		/*final EvalGamesThread evalThread = 	EvalGamesThread.construct
											(
												evaluation, report, game, options, AIName, 
												numberTrials, thinkTime, maxTurns,
												metricsToEvaluate, weights, useDatabaseGames
											);*/
		
		System.err.println("We getting in in");
		return evaluateGame(evaluation, report, game, options, AIName, numberTrials, thinkTime, maxTurns, metricsToEvaluate, weights, useDatabaseGames);
		
		
		//evalThread.setDaemon(true);
		//evalThread.start();
	}
	
	/**
	 * The main method
	 * @param args
	 */
	public static void main(final String[] args)
	{
		// Run Ludii
		//StartDesktopApp.main(new String[0]);
		
		// check all metrics are correct
		// put appropriate weights
		// put appropriate settings for iterations, think time and the skill trace
		// put the appropriate use database trials thing
		
		// save the results
		// use EvalGames.EvaluateGame directly
		// build the cvs file as we go like in the evaluateAll function
		
		String gameName = "20 Squares.lud";
		File gameFile = new File(".\\20 Squares.lud");
		final Game game = GameLoader.loadGameFromFile(gameFile);
		
		// check if everything works
		
		System.err.println("We starting");
		
		
		final List<Metric> metrics = new Evaluation().dialogMetrics();
		final ArrayList<Double> weights = new ArrayList<>();
		
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		weights.add(1.0);
		
		final int maxTurns = 1000;
		final int numberIterations = 100;
		
		double thinkTime = 0.5;
		String AIName = null;
		AIName = "Biased MCTS";
		
		/*
		switch(comboBoxAIAgents.getSelectedItem().toString())
		{
			case "Random": AIName = "Random"; break;
			case "Very weak AI": AIName = "Ludii AI"; thinkTime = 0.1; break;
			case "Weak AI": AIName = "Ludii AI"; thinkTime = 0.5; break;
			case "Strong AI": AIName = "Ludii AI"; thinkTime = 2.0; break;
			case "Very strong AI": AIName = "Ludii AI"; thinkTime = 5.0; break;
			case "Custom": AIName = comboBoxAlgorithm.getSelectedItem().toString(); thinkTime = Double.valueOf(textFieldThinkTime.getText()).doubleValue(); break;
		}*/
		
		for (final Metric m : metrics)
		{
			if (m instanceof IdealDuration)
			{
				((IdealDuration)m).setMinTurn(90);
				((IdealDuration)m).setMaxTurn(120);
			}
			
			if (m instanceof SkillTrace)
			{
				((SkillTrace)m).setNumMatches(10);
				((SkillTrace)m).setNumTrialsPerMatch(10);
				((SkillTrace)m).setHardTimeLimit(600);
				((SkillTrace)m).setOutputPath("C:\\Users\\tiago\\KCODE\\Tese\\ludii\\ludii-1.3.14" + File.separatorChar);
			}
		}
		
		//final Report report = new Report();
		//report.setReportMessageFunctions(new ReportMessengerGUI(StartDesktopApp.desktopApp()));
		
		// Make a deepcopy of the weights to be used.
		final ArrayList<Double> weightsCopy = new ArrayList<>();
		for (final Double d : weights)
			weightsCopy.add(new Double(d.doubleValue()));
		
		
		final String outputFilePath = "EvalResults.csv";
		String outputString = "GameName,";
		for (int m = 0; m < metrics.size(); m++)
		{
			outputString += metrics.get(m).name() + ",";
		}
		outputString = outputString.substring(0, outputString.length()-1) + "\n";
		
		System.err.println("We getting in");
		outputString += evaluate(StartDesktopApp.desktopApp(), null, numberIterations, maxTurns, thinkTime, AIName, metrics, weightsCopy, false);
		//AIPlayer.AIEvalution(StartDesktopApp.desktopApp(), report, numberIterations, maxTurns, thinkTime, AIName, metrics, weightsCopy, useDatabaseTrialsCheckBox.isSelected());
		//DesktopApp.view().tabPanel().select(TabView.PanelAnalysis);
		System.err.println("We finished");
		
		try (final BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilePath, false)))
		{
			writer.write(outputString);
			writer.close();
		}
		catch (final IOException e1)
		{
			e1.printStackTrace();
		}
	}

}